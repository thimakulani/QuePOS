@page "/transection/index"

@using MudBlazor

<MudGrid>
    <MudItem xs="12" sm="8" md="6" lg="6">
        <MudPaper Elevation="4" Class="p-4">
            <MudText Style="margin: 10px" Typo="Typo.h5">Transaction</MudText>
            <br />
            <MudGrid Class="mb-2" Justify="Justify.SpaceAround">
                <MudButton Variant="Variant.Outlined" OnClick="ShowScanner" StartIcon="@Icons.Material.Outlined.QrCodeScanner" >Scan </MudButton>
                <MudButton Variant="Variant.Outlined" OnClick="ShowProducts" StartIcon="@Icons.Material.Outlined.Add">Get Products</MudButton>
            </MudGrid>
            <MudList Dense T="string" Class="mt-2">
                @foreach (var item in cartItems)
                {
                    <MudListItem>
                        <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Spacing="2">
                            <!-- Item Name -->
                            <MudText Typo="Typo.h6">@item.Name</MudText>

                            <!-- Quantity Stepper -->
                            <MudStack Direction="Row" AlignItems="AlignItems.Center" Spacing="1">
                                <MudIconButton Icon="@Icons.Material.Filled.Remove" OnClick="() => UpdateQuantity(item, item.Quantity - 1)" Disabled="item.Quantity <= 1" Size="Size.Small" />
                                <MudText>@item.Quantity</MudText>
                                <MudIconButton Icon="@Icons.Material.Filled.Add" OnClick="() => UpdateQuantity(item, item.Quantity + 1)" Size="Size.Small" />
                            </MudStack>

                            <!-- Total Price -->
                            <MudText Typo="Typo.h6">@((item.Quantity * item.Price).ToString("C"))</MudText>

                            <!-- Remove Item Button -->
                            <MudIconButton Icon="@Icons.Material.Filled.Delete" OnClick="() => RemoveItem(item)" Color="Color.Error" />
                        </MudStack>
                    </MudListItem>
                }
            </MudList>



            <MudDivider Class="my-2" />
            <MudText Typo="Typo.h6">Total: @totalAmount.ToString("C")</MudText>

            <MudButton Variant="Variant.Filled" Color="Color.Success" Class="mt-2" OnClick="ProcessSale">Complete Sale</MudButton>
        </MudPaper>
    </MudItem>
</MudGrid>


<MudDialog @bind-Visible="products_visible" Options="_dialogOptions">
    <TitleContent>
        <MudListSubheader>
        </MudListSubheader>
    </TitleContent>
    <DialogContent>
        <MudItem>
            <MudList T="string"  ReadOnly="false" CheckBoxColor="MudBlazor.Color.Tertiary">

                @foreach (var item in products)
                {
                    <MudListItem >

                        <MudStack Row="true" AlignItems="AlignItems.Center"  Spacing="2">
                            <MudText>@item.Price</MudText>
                            <MudText>@item.Name</MudText>
                            <MudSpacer />
                            <MudIconButton Icon="@Icons.Material.Rounded.Add" />
                        </MudStack>
                    </MudListItem>
                }
            </MudList>
        </MudItem>
    </DialogContent>
    <DialogActions>
        <MudButton Color="MudBlazor.Color.Primary" OnClick="CloseDlg">Close</MudButton>
    </DialogActions>
</MudDialog>





@code {
    private List<Product> products = [];
    @inject ISnackbar Snackbar;
    private readonly DialogOptions _dialogOptions = new() { FullWidth = true };
    private bool products_visible;
    [Inject]
    private IHttpClientService HttpClientService { get; set; }
    private List<CartItem> cartItems = [];
    private double totalAmount => cartItems.Sum(i => i.Quantity * i.Price);

    private Task<IEnumerable<string>> SearchProducts(string value, CancellationToken cancellationToken)
    {
        return Task.FromResult(products
            .Where(p => p.Name.Contains(value, StringComparison.OrdinalIgnoreCase))
            .Select(p => p.Name));
    }
    private void CloseDlg()
    {

    }    
    private void ShowScanner()
    {

    }    
    private void ShowProducts()
    {
        products_visible = true;
    }
    protected override async Task OnInitializedAsync()
    {
        await GetProducts();
        await base.OnInitializedAsync();
    }
    private void AddToCart(string productName)
    {
        var product = products.FirstOrDefault(p => p.Name == productName);
        if (product != null)
        {
            var existingItem = cartItems.FirstOrDefault(i => i.Name == product.Name);
            if (existingItem != null)
            {
                existingItem.Quantity++;
            }
            else
            {
                cartItems.Add(new CartItem { Name = product.Name, Quantity = 1, Price = (double)product.Price });
            }
        }
    }

    private void UpdateQuantity(CartItem item, int quantity)
    {
        item.Quantity = quantity;
    }

    private void RemoveItem(CartItem item)
    {
        cartItems.Remove(item);
    }

    private void ProcessSale()
    {
        // Logic for processing the sale (e.g., saving transaction, printing receipt, etc.)
        cartItems.Clear();
    }
    private async Task GetProducts()
    {
        try
        {
            //string id = FormFactor.GetSession()
            products = await HttpClientService.GetAsync<List<Product>>("/api/products/all/store");
        }
        catch (HttpRequestException ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"An unexpected error occurred: {ex.Message}", Severity.Error);
        }
        finally
        {
            StateHasChanged();
        }
    }


    private class CartItem
    {
        public string Name { get; set; } = "";
        public int Quantity { get; set; } = 1;
        public double Price { get; set; } = 0;
    }
}
